% -*- root: ../../DAT2-A423_Project_Report.tex -*-
\section{Software Testing}
During the planning phase of the project we decided to continually test the code that we wrote.

Our strategy for testing revolved around one member of the group creating tests, for each new component, method and logical statement.
The aim of this continual testing alongside the software development, was to catch errors and bugs as soon as possible, so there would not be problems further down the line.
This would then in turn minimize time and effort otherwise used on debugging, and therefore also lead to a more stable programme.
The aforementioned tests would additionally improve the maintainability of the software, allowing future changes and upgrades.

The construction of tests were done using the open source unit testing framework NUnit.
Using this framework allowed the creation of tests to be streamlined and automated, allowing each group member to frequently test the new components they were creating.

\subsection*{BitList}
\lstinline|BitList| is a custom implementation based on the \lstinline|BitArray| from the .Net framework, 
It is often used in our programme, which means that it has to be tested thoroughly.
First of all, it has to act like a \lstinline|List|, which includes being able to have values inserted at specific indices.
This is tested in the \lstinline|InsertTest_IndexInMiddle_InsertionOnIndex()| method.
This test passes.\\
Another property of the \lstinline|BitList| is that \lstinline|0| should be evaluated to \lstinline|false|, and \lstinline|1| should be \lstinline|true|.
This is also tested, and the test passes.
% Something something CheckedAdd()

\subsection*{Vertex}
\lstinline|Vertex| is compromised of two sample values, a message, and a modulo value.
It has a single method, \lstinline|ToString()|, which is simply a string containing each sample value.
All in all, a simple class to test.
The test, \lstinline|ToStringTest()|, is an assertion that, when creating a \lstinline|Vertex| object from two sample values, a message values, and a modulo value, the string returned from \lstinline|ToString()| is equal to the two sample values concatenated.
This test passes, making us able to test other classes that make use of \lstinline|Vertex|.

\subsection*{Edge}
\lstinline|Edge| is a crucial class in our programme.
This class has five properties, two of which are the vertices that define the edge, one weight value, and two bools defining the properties of vertex value switching.
Other than that, the class has no methods that define functionality, it just has to be correctly compared to other edges and be printed.
This means that testing the class is fairly easy.
The first test, \lstinline|Edge_ToStringTest()|, creates an \lstinline|Edge| object from two defined vertices, and then asserts that it prints the correct vertex values.
This test passes.\\
The goal of second test, \lstinline|ComparisonEdgesWithDifferentWeight_LowestWeightFirst()|, is to test difference between two edges.
We create two vertices with different sample values, and assert that one edge is higher positioned in the sort order than the other.
This test as well.\\
The final test, \lstinline|Equal_EdgesWithSameVerticesAndValues_True|, asserts that two edges with the same vertices, message values, and modulo values, are equal.
This test passes, which means that \lstinline|Edge| behaves as expected.

\subsection*{Graph}
The \lstinline|Graph| class has two properties: \lstinline|List<Vertex>| and \lstinline|List<Edge>|.
As with \lstinline|Vertex| and \lstinline|Edge|, \lstinline|Graph| overrides \lstinline|ToString()|, which means that it will have to be tested.
\lstinline|Graph|'s \lstinline|ToString()| returns a header as well as a list of vertex sample values.
To test this, we create a number of different vertices and adding them to the graph.
The \lstinline|ToString()| method is then compared to a string with an expected \lstinline|List<Vertex>|.
This test passes.\\
Another method to be tested is \lstinline|GetSwitches()|.
This is done by creating a graph with a number of different edges, each with a different set of vertices.
Then we assert that the \lstinline|List<Edge>| returned by the method is the same as an expected \lstinline|List<Edge>| kept after the method is called.
This test passes as well.

\subsection*{HuffmanElement}
The \lstinline|HuffmanElement| class has three properties: runsize, length, and codeword.
Objects of this class must be comparable to other objects of the same class, which means that \lstinline|CompareTo()| is implemented.
This has to be tested.
Two Huffman elements are created with different runsizes and codewords.
It is then asserted that the position of the element with the smaller runsize is before the other element in a sorted list.
This test passes.\\
Another method that is being tested is \lstinline|Equals|, since that is overridden.
Two Huffman elements are created with different runsizes, codewords, and lengths, and they are compared using \lstinline|Equals()|.
It is asserted that the first set of elements are not equal, since they have different properties.
In the same test, two elements with the same properties are created, and it is asserted that they are actually equal.
Both assertions are true, making this test pass.\\
The last test is for \lstinline|ToString()|.
A Huffman element is created, and it is asserted that a formatted string with expected variables is the same as the call to \lstinline|ToString()|.
This test passes as well, making \lstinline|HuffmanElement| behave as expected.

\subsection*{HuffmanTable}
This class is fairly comprehensive, as it has a lot of methods that need to be tested.
It is compromised of a dictionary of Huffman elements.
First, we need to test that a table has access to an element's codeword.
A number of Huffman elements - the first of which has a codeword \lstinline|2| - are created and added to a table.
It is then asserted that the number \lstinline|2| and the codeword of the table's first element are equal.
This test passes.\\
Next, we need to test \lstinline|Combinations()|, which returns a \lstinline|byte[]| of the number of codes of a specific length.
Two \lstinline|HuffmanElement| objects are made with different runsizes and codewords, but same length: 8.
It is asserted that there are two elements of length 8, and this is true, making the test pass.\\
\lstinline|HasCode()| checks if a certain code is found in the table.
To test this, a table with a number of \lstinline|HuffmanElement| objects are created.
It is then asserted that the runsize of one of the elements is equal to an expected value (in our test-case 0).
It is also tested that, if no element has a specified code, it returns \lstinline|null|.
These tests pass.\\
\lstinline|ToString()| is overridden, and it is asserted that it returns an expected string.
It works as expected.\\
Lastly, we need to test \lstinline|GetElementFromRunSize()|, which, as the name implies, returns a \lstinline|HuffmanElement| from a specific runsize.
A table with a number of \lstinline|HuffmanElement| objects is created, one of which is tested against an expected input to \lstinline|GetElementFromRunSize()|.
The test passes, making \lstinline|HuffmanTable| behave as expected.

\subsection{QuantizationTable}
\lstinline|QuantizationTable| is yet an important class in our programme, and thus it needs to be tested.
Since the table entries need to be arranged in a zigzag order, it is tested in \lstinline|QuantizationTableTest_Zig_Zag_Entries()|.
A default quantization table is created and arranged in a zigzag order in \lstinline|QuantizationTable|'s constructor.
A manually calculated order is compared to the order in the constructor, and it is asserted that they are equal.
This test passes.\\
The \lstinline|Scale()| method scales quantization values using a certain quality as input.
An expected table is manually calculated, and it is asserted that this is the same as the one returned by \lstinline|Scale|.
This test passes.\\
\lstinline|Scale()| should throw exceptions when the quality parameter is above 100 or below 0.
It is asserted that the method throws \lstinline|OutOfRangeException()| when called with a quality of -4 and 101.
These tests pass.\\
Since we know that \lstinline|QuantizationTable| behaves as expected, we can comfortably use it in \lstinline|JpegImage|.

\subsection*{JpegImage}
The \lstinline|JpegImage| class is also relatively comprehensivea, making the need for tests large.
The first test is simple, testing if the modulo value of an instance of the class gets set.
Since it is a private variable, we need to use \lstinline|PrivateObject| as previously described.
The test passes.\\
The next two tests test whether exceptions are thrown when an instance of \lstinline|JpegImage| is created without a \lstinline|Bitmap| cover image and when \lstinline|Save()| is called without a \lstinline|JpegWriter|.
These tests pass.\\
% CalculateCosineCoefficients_Test()
\lstinline|BreakDownMessage_Test()| tests whether the \lstinline|_breakDownMessage()| method behaves as expected.
\lstinline|PrivateObject| is once again required, as we need to look at the value of a private variable.
A message is broken down into a \lstinline|byte[]| length and m-value, and encode it.
It is then asserted that a manually calculated encoding of the same message and the value that the method returns is the same.
This test passes.\\
The next test tests whether \lstinline|_padCoverImage()| works as expected when the dimensions of an image is divisible by 16.
It is asserted that \lstinline|_padCoverImage()| does not do anything to the image, and this test passes.\\
However, when the dimensions of an image is not divisible by 16 (e.g. 15x15), it is expected that \lstinline|_padCoverImage()| returns a padded image.
It is then asserted that the returned image and an expected image with dimensions divisible by 16 are the same.
This test passes.\\
Much like the previous test, colour should also be the same in an original image and a padded version.
This is tested by picking a pixel from a specific location from the original image, and an equivalent pixel from the padded image, and asserting that the colour is the same.
This test passes.\\
The \lstinline|_copyBitmap()| method is tested as well.
It is asserted that a specific pixel from the original image and a copied image are the same.
This test passes.\\
Another test required is for \lstinline|_splitToChannels()|, which tests that a pixel with specific RGB-values is correctly split into YCbCr-channels.
This test passes as well.\\
The method \lstinline|_downSample()| is tested by downsampling an array of \lstinline|float|, and asserting that the returned array is the same as a manually calculated array.
This test passes.\\
% Block16ToBlock8_Test() might be checked
The \lstinline|_discreteCosineTransform()| method must be tested as well, since that is an essential part of our programme.
This is done by creating an instance of \lstinline|JpegImage| and then asserting that a table of 64 manually calculated cosine values is the same as the table returned from the method under test.
Since it returns a \lstinline|float[]|, we set a tolerance for when a number is equal to another.
The test passes.\\
The \lstinline|_c| method is tested four times with different inputs.
The test passes in all four cases, since the expected output is equal to the ones returned from the method.\\
\lstinline|_quantization()| is under test as well, and this is done by filling an array with 64 manually calculated quantized values and asserting that it is the same as the array returned by \lstinline|_quantization()|.
This test passes as well.\\
Tests are also conducted for \lstinline|_addVertices()| and \lstinline|_addEdge()|.
\lstinline|_addVertices| add vertices to a graph, where \lstinline|sampleValue1| and \lstinline|sampleValue2| are incremented by 2 for each vertex, starting from 0 and 1, respectively.
We create a number of vertices with the same properties and manually add these to another graph, and assert that this graph contains the same vertices as the one in the method.
\lstinline|_addEdge()| is tested in much the same way, and both tests pass.\\
We can now decide, based on the test results of the \lstinline|JpegImage| class, that it works as expected, and can be safely used in our programme.

% Maybe the first paragraph should be in design
% Plan to maybe add a "case study" with an example from our program
% Need to make some assumption regarding tests