% -*- root: ../../DAT2-A423_Project_Report.tex -*-
%Digital steganography has proven to be a substantial task and working with this topic has presented several hurdles. 
Through the ages people have sent concealed messages to each other, and now with the help of digital steganography it has become more accessible.

Our problem analysis allowed us to establish  boundaries of the topic as well as goals to complete.
We came to the conclusion that it was not as important to try and get messages across social media, but instead more important to get messages across in the most discrete and undetectable way possible.
We did learn from social media, that the most common image format online is JPEG. 

We discovered through steganalysis that by using a simple method such as LSB, it was not possible to discretely send messages, as even a simple colour histogram could reveal the existence the message.
Instead we needed a method more resilient to statistical analysis.
The graph-theoretic approach to steganography described in section \ref{sec:graphtheory} was the method we needed.

What we wanted to achieve was modifying the method to work with JPEG images.
We wanted the algorithm to be able to encode the data without incurring visual distortion to the image.
The product also had to be implemented in an object-oriented programming language.

To hide the data in JPEG images, we first had to design and implement a JPEG encoder.
After having a functional JPEG encoder, we designed and implemented the graph-theoretic method along with a decoder to be able to retrieve the embedded message.
The programme was tested using the .NET testing framework NUnit. 

This resulted in the programme \textit{Stegosaurus}, that can encode messages discretely as well as decode the messages, and this is something that we desired when we chose this method. 

Our tests of the programme showed that it was impossible to discover the method by simply looking at colour histograms.
Looking back to figure \ref{fig:histogramsComparisons} we can see that there were barely any differences between the cover image encoded as JPEG in figure \ref{fig:gt2Histo} and the stego image saved as JPEG in figure \ref{fig:gtHisto}.
Even though there are some differences, these are negligible.
The euclidean distance in the colour channels are generally greater using the graph-theoretic method instead of LSB, though looking back on section \ref{fig:ResultEncoding} the changes are not visible to the human eye when encoding the data.

This means, that it is possible for us to share images with concealed messages without raising suspicion, which was our goal.
We have succeeded in creating a programme which fulfils the problem statement and we have shown that the graph-theoretic method works with JPEG images. 
The programme has been tested and we have found the testability of it to be low. 
This is partly due to the amount of private methods instead of splitting the functionality up into several more, smaller classes. 
Each class would then handle a subset of the problem, making it easier to test the parts individually. 
Additionally, the modularity of the programme would have been higher with the introduction of more classes.
An example of such a class could be \lstinline|GraphEncoder| class that would accept a list of numbers, and use the graph-theoretic method on them. 
That would move a lot of the functionality out of the \lstinline|JPEGImage| class and make our implementation of the method much more versatile. 
In conclusion, we accomplished what we intended to do with our problem statement, but there was room for improvement in relation to our teamwork with the cluster group. 

\section{Conclusion on the cluster work}

With our programme we hoped to contribute to the cluster group's collective project.
Using an object-oriented programming language allowed us to define interfaces. This made it easier and less time-consuming for us to create a graphical user interface and to help the ITC group.
These interfaces were made far in advance, so both groups could them in their development without being dependant on each other.

As described in section \ref{sec:confines}, the grounds for working with the method implemented, was to help improve our understanding and help both groups with creating better projects. 
This did not happen quite as planned, due to insufficient communication.
Thankfully this was not catastrophic as there had also been made an agreement that the groups should be able to work together individually and this was how the course of the project went.

It was hard for three groups with completely different curricula, ideas, and requirements to come together and work on a shared project.
Given enough time and more in-depth talks with each other, it could have worked, but none of the groups was prepared or experienced enough for the challenge.
It seems like this kind of cluster project is well-suited for a corporate setting, where the goal is to develop a complete solution across all teams.
In a university setting, however, each group was required to learn and possibly develop something based on their respective curriculum, and it makes sense that they first and foremost focus on their own project, and not on cluster work, which can only be considered a ``bonus objective'' that can be skipped.

