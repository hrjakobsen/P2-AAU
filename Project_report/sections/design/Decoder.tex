\section{Decoding}
To find the encoded text using the Graph-Theoretic Approach, the first step is to read in the Huffman tables from the JPEG-file, making it possible to look up the code written in the scan-data session of the file. 
\input{sections/design/FindHuffmanTable.tex}

\subsection*{Decoding the Huffman-encoded Values}
As explained in section \ref{sec:graphJPEG}, the hidden message will be hidden in pairs of two quantized values in a certain modulo.
To get the data out, we would have to first read the first 16 AC values that are not 0, in order to find what modulo the message is hidden with, and the length of the message, to not decode the whole image, and to give back the actual message as an output.
Finding the length of message, as well as the value of modulo, requires you to decode the scan data as follows
\begin{enumerate}
	\item Read in 1 Huffman DC element for the Y channel
	\item Read in 63 Huffman AC elements for the Y channel, or until EOB
	\item Repeat step 1 and 2, three more times
	\item Read in 1 Huffman DC element for the cb channel
	\item Read in 63 Huffman AC elements for the cb channel, or until EOB
	\item Read in 1 Huffman DC element for the cr channel
	\item Read in 63 Huffman AC elements for the cr channel, or until EOB
\end{enumerate}
To decode the huffman-encoded values according to the table shown in section \ref{tab:huffmanCodes}, the values with $1_2$ as the most significant bit, is a positive number, and can thus, in a language such as C\#, just be used without doing any calculations on it, seeing the containing variable's most most-significant bit, will be $0_2$.

To get the negative values, we'll have to do some calculations. 
First, we notice how with each category, the minimum number is the same as adding one to the $2^n$ negative value, and the higher the bit-value becomes, the higher the actual value becomes as well. 
Based on this information, we've derived algorithm \ref{algDecodeHuffmanValue}
\input{sections/design/decodeHuffmanValue.tex}
These values, and the preceding zeroes, will have to be read into an array in zig-zag ordering.

\subsection*{Decoding the Message}
We'll need 16 non-zero values in order to find the length of the encoded message, and the value of modulo, which we'll need to use in order to decode it. To find the length, we need to do the following:
\begin{enumerate}
	\item Bitshift a variable which starts being equal to 0, two times to the left
	\item Add two elements together
	\item Take modulo 4 of the result
	\item Add the result to the variable mentioned in step one
	\item Repeat steps 1-4 six more times
\end{enumerate}
The value of modulo is hidden within the remaining two values, which can be found by doing steps 2 and 3. This value however, will just tell us what value modulo should be, thus we will need to implement a switch, which assigns the right value for the modulo variable.

The possible values will be as follows
\begin{itemize}
	\item 0. Value of modulo is 2
	\item 1. Value of modulo is 4
	\item 2. Value of modulo is 16
	\item 3. Value of modulo is 256
\end{itemize}
Once the length has been found, we can keep decoding the scan data segment until enough AC coefficient has been read to decode the full message, using the modulo value we just found.

When enough values has been read, the decoding process of the message is the same as listed in the beginning of thus subsection, except the value of modulo may be different. 
Each letter will then have to be written to an array and returned to the user, since this array, will contain the message that was encoded in the JPEG picture.