% -*- root: ../../DAT2-A423_Project_Report.tex -*-
\section{Implementation of a JPEG image}

\subsection{Working with bits}
While working with JPEG images bit-patterns and bit-wise operations often occur.
Due to hardware limitations, a single bit in the memory cannot be changed individually, and we can only address the individual bytes.
There are now two ways that we can go about this:
Either we use bytes to represent bits, and effectively waste 7 bits of memory for each bit, or we use the class \lstinline|BitArray| from the \lstinline|System.Collections| library.

The \lstinline|BitArray| seemed like the way to go, and we implemented a class \lstinline|BitList| which implemented List-like features like \lstinline|Add| and \lstinline|Insert| while using the \lstinline|BitArray| to store our data.
The implementation can be seen in appendix \ref{app:C}. 

The \lstinline|BitArray| offers the functionality of modifying the length of the array, so that more values can be added.
This means that every time the \lstinline|BitList| runs out of space in the underlying \lstinline|BitArray|, we simply multiply the length of the array by 2, so that more values can be added.
This makes appending to the array relatively fast, since we have enough room to add more values most of the time.
Inserting values in the middle of the array proved to be much more difficult, however.

When inserting a value into the array, all values after the value to be inserted have to be shifted, so that room is made from the new value.
In an example 512x512 image, we have over 750,000 bits to save, and if we were to insert a bit in the beginning of the array, we would have to move 750,000 elements in the array.
All in all a very computationally expensive operation.

So while the \lstinline|BitArray| seemed promising in theory, saving us a lot of memory, the need of inserting bits into the middle of the array makes using the \lstinline|BitArray| infeasible.
We are now back at a point where it may seem worth it to waste the memory, and just use a list of bytes instead of the \lstinline|BitArray|.
Unfortunately this brings its own problems to the table.
Instead of having $\mathcal{O}(1)$ access time we would have $\mathcal{O}(n)$, which we want to avoid.
We figured out a solution to these problems:
We simply stop inserting values into the middle of the array.
Of course it is not as easy as that, as we still need to insert 8 zeros if we happen to encode 8 consecutive ones in the scan data, but instead of doing this check after the encoding process, we do in on-the-fly instead.
With the added method \lstinline|CheckedAdd| to \lstinline|BitList| which can be seen in appendix \ref{app:D}, we now do the check when values are added, instead of after. 