% -*- root: ../../DAT2-A423_Project_Report.tex -*-
To do that, we implemented algorithm \ref{huffmanAlgo}, which gave us all the information we needed about the Huffman table, including what kind it was, so that we could store it in the appropriate property. 
Checking the first four bits in the output parameter ensured that we knew whenever the Huffman table was a DC table, or an AC table. 
Reading the remaining four bits gave us the ID of the Huffman table, which told us when the table was for the luminance channel, or the chroma components.
After this, it was then time to read in all the bytes from the scan-data section. As long as no header was being read, the byte would be written to a byte-array, which would then be turned into a \lstinline|BitArray|.
Working on the \lstinline|BitArray| is the fastest possible solution, since we would read each bit from start to end and would not have to add additional bits in the future. The \lstinline|BitArray| implementation however, lists each bit in reverse order, meaning we would have to read from the array in reverse as well, which would likely affect performance considering how caches work.
To avoid this, we would instead have to use the \lstinline|BitList| class again, which would add each bit in the correct order, and since a \lstinline|List| is just an array which size can be dynamically increased as required. 

The Decoder implements an interface, which specifies the decoder to have four properties, each containing the respective Huffman table, and the method \lstinline|decode()|, which returns a \lstinline|byte| array. 
The Huffman tables are read from a stream from a given filepath. This stream gets assigned to a \lstinline|BinaryReader|, since what we would read, would be bytes. All of this can be seen in the constructor in Listing \ref{code:decoderConstructor}.
\lstinputlisting[firstline=36, firstnumber=36, lastline=54, label={code:decoderConstructor}, caption={The Decoder constructor}]{../Programmer/Stegosaurus/Stegosaurus/JPEG/JPEGDecoder.cs} 

The listing also shows how we find the HuffmanTable and store it in the right property, based on its ID and Class.

Once we have read in all the lengths of the Huffman-encoded values, the next we will be reading, is the runsize of the Huffman codes. To get the correct code, we will bitshift the current value we have by one to the left, once there are no more huffmancodes to read of the current length, then increment the current length by 1, as described in algorithm \ref{huffmanAlgo}.

After implementing the rest of the algorithm, we will end up with a complete \lstinline|HuffmanTable|.
