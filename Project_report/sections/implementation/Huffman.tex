To do that, we implemented algorithm \ref{huffmanAlgo}, which gave us all the information we needed about the Huffman table, including what kind it was, so that we could store it in the appropriate property. 
Checking the first four bits in the output parameter ensured that we knew whenever the Huffman table was a DC table, or an AC table. 
Reading the remaining four bits gave us the ID of the Huffman table, which told us whenever the table was for the luminance channel, or the chroma components.
After this, it is now time to read in all the bytes from the scan-data section. As long as no header is being read, the byte will be written to a byte-array, which will then be turned into a \lstinline|BitArray|.
Working on the \lstinline|BitArray| is the fastest possible solution, since we will read each bit from start to end and will not have to add additional bits in the future. The \lstinline|BitArray| implementation however, lists each bit in reverse order, meaning we will have to read from the array in reverse as well, which will likely affect performance considering how caches work.
To avoid this, we will instead use the \lstinline|BitList| class again, which will add each bit in the correct order, and since a \lstinline|List| is just an array whose size can be dynamically increased as required. 

The Decoder implements an interface, which specifies the decoder to have four properties, each containing the respective Huffman table, and the method \lstinline|decode()|, which returns a \lstinline|byte| array. 
The Huffman tables will be read from a stream from a given filepath. This stream will be assigned to a \lstinline|BinaryReader|, since what we will read, will be bytes. All of this can be seen in the constructor in Listing \ref{code:decoderConstructor}
\lstinputlisting[firstline=36, firstnumber=36, lastline=54, label={code:decoderConstructor}, caption={The Decoder constructor}]{../Programmer/Stegosaurus/Stegosaurus/JPEG/Decoder.cs} 

The listing also shows how we find the HuffmanTable and store it in the right property, based on its ID and Class

Once we've read the in all the lengths of the Huffman-encoded values, the next we'll be reading, is the runsize of the Huffmancodes. To get the correct code, we will bitshift the current value we have by one to the left, once there are no more huffmancodes to read of the current length, then increment the current length by 1, as described in algorithm \ref{huffmanAlgo}.

After implementing the rest of the algorithm, we'll end up with a complete \lstinline|HuffmanTable|.
